problem 11
解法1:暴力解法
超时
class Solution {
public:
    int maxArea(vector<int>& height) {
        int len=height.size(),ans=0,les=0;
        for(int i=0;i<len;i++){
            for(int j=0;j<len;j++){
                les=min(height[i],height[j]);
                int q=abs(i-j);
                ans=max(les*q,ans);
            }
        }
        return ans;
    }
};
解法2 双指针贪心 需要证明正确性 详见 https://leetcode-cn.com/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/
class Solution {
public:
    int maxArea(vector<int>& height) {
        int len=height.size();
        int p1=0,p2=len-1,ans=0,res=0;
        while(p1<p2){
            ans=(p2-p1)*min(height[p1],height[p2]);
            res=max(res,ans);
            if(height[p1]<height[p2]) p1++;
            else p2--;
        }
        return res;
        }
};

problem 15
解法1 code失败 排序+双向搜索+二分搜索 有一个中间变量无法记下，stl使用不熟练，未来请补充上
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<int> ans;
        vector<int> sum;
        int len=nums.size(),q=0;
        if(len<3) return {};
        sort(nums.begin(),nums.end());
        int pos=lower_bound(nums.begin(),nums.end(),0)-num.begin();
        //ans pos--<0  ans pos++>0
        for(int i=pos;i<len;i++){
            for(int j=i+1;j<len;j++){
                sum[q++]=nums[i]+nums[j];
            }
        }
        for(int i=pos-1;i>=0;i--){
            for(int j=0;j<q-1;j++){
            if(nums[i]+sum[j]==0){
                ans_pushback()//写到这里发现q无法分解成i、j,无法输出答案
            }
            }
        }
    }
};
解法2 排序后用双指针 L=i+1, R=len-1
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        //vector<int> sum;
        int len=nums.size(),q=0;
        if(len<3) return {};
        sort(nums.begin(),nums.end());
        //int pos=lower_bound(nums.begin(),nums.end(),0)-num.begin();
        for(int i=0;i<len;i++){
            if(nums[i]>0) break;
            if(i>0 && nums[i]==nums[i-1]) continue;
            int L=i+1,R=len-1;
            while(L<R){
                int sum=nums[i]+nums[L]+nums[R];
                if(sum==0) {
                    ans.push_back({nums[i],nums[L],nums[R]});
                    while(L<R && nums[L]==nums[L+1]) L++;//如果循环数量可能是多个时，我们用while，如果是1个或者可知数量的，可以用if
                    while(L<R && nums[R]==nums[R-1]) R--;
                    L++;
                    R--;
                }
                else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }
        return ans;
    }
};
解法2精简代码
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& A) {
        sort(begin(A), end(A));
        vector<vector<int>> ans;
        int N = A.size();
        for (int i = 0; i < N - 2; ++i) {
            if (i && A[i] == A[i - 1]) continue;
            int L = i + 1, R = N - 1;
            while (L < R) {
                int sum = A[i] + A[L] + A[R];
                if (sum == 0) ans.push_back({ A[i], A[L], A[R] });
                if (sum >= 0) {
                    --R;
                    while (L < R && A[R] == A[R + 1]) --R;
                }
                if (sum <= 0) {
                    ++L;
                    while (L < R && A[L] == A[L - 1]) ++L;
                }
            }
        }
        return ans;
    }
    };
    
